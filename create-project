#!/usr/bin/env python3
import subprocess
from datetime import datetime
import argparse

from os import system, path, mkdir, name

from src.content import *
from src.utils import *

parser = argparse.ArgumentParser(description='Creates python project, initialize git repository '
                                             'and creates virtual environment')

parser.add_argument(dest='project_name', nargs='+',
                    help='name of python project (must be CamelCase)')

parser.add_argument('-s', '--secure', dest='secure', action='store_true',
                    help='makes project secure')

parser.add_argument('-q', '--quiet', dest='quiet', action='store_true',
                    help='quiet mode')

parser.add_argument('--create-link', dest='create_link', action='store_true',
                    help='creates symbolic link in ~/bin')

parser.add_argument('--script-name', dest='script_name', action='store', default=None,
                    help='name of main script')

parser.add_argument('--git-login', dest='git_login', action='store', default=None,
                    help='GitHub login')

parser.add_argument('--license', dest='license_', action='store', default='mit',
                    choices=list(licenses.keys()),
                    help='license for your project')

args = parser.parse_args()

forbidden = ['src', 'test', 'README.md', 'requirements.txt', 'LICENSE', 'tests.py', 'utils.py',
             'Dockerfile', '.git', '.gitignore', '.gitattributes', 'venv']


def create_project(project_path):
    if not is_camel_case(project_path):
        error_pars(parser.prog, f'"{project_path}" must be CamelCase')
        return

    if args.script_name is None:
        script_name = get_script_name(path.basename(project_path))
        if script_name in forbidden:
            script_name += '_'
    else:
        if len(args.project_name) > 1 and args.create_link:
            error_pars(parser.prog, 'you can\'t use --create-link and --script-name together if more then 1 project')
            return
        else:
            if args.script_name in forbidden:
                error_pars(parser.prog, f'you can\'t use script name "{args.script_name}"')
                return
            else:
                script_name = args.script_name

    try:
        mkdir(project_path)
    except FileExistsError:
        error_pars(parser.prog, f'project "{project_path}" already exists')
        return

    if args.git_login is None:
        github_nickname = subprocess.check_output(['git', 'config', 'user.name']).decode().strip()
    else:
        github_nickname = args.git_login

    dirs = ['test', 'src']
    files = (
        ('.gitignore', gitignore),
        ('.gitattributes', gitattributes),
        ('README.md',
         readme_md.format(project_path=project_path, github_nickname=github_nickname, script_name=script_name)),
        (script_name, main_py),
        ('requirements.txt', ''),
        ('LICENSE', licenses[args.license_].format(year=datetime.now().year, github_nickname=github_nickname)),
        (path.join(dirs[0], 'tests.py'), tests_py),
        (path.join(dirs[1], 'utils.py'), utils_py)
    )

    init_all(project_path, dirs, files, args.quiet)

    if name == 'posix':
        system(f'chmod u+x {path.join(project_path, script_name)}')  # разрешение на запуск

        if args.create_link:

            link_path = path.abspath(path.join(project_path, script_name))
            try:
                create_symbolic_link(link_path)
            except FileNotFoundError as e:
                error_pars(script_name, str(e), exit_code=0)
            except FileExistsError as e:
                error_pars(script_name, str(e), exit_code=0)

        if args.secure:
            secret(project_path)

    git_init(project_path, args.quiet)  # last


def main():
    for project in args.project_name:
        create_project(project)


if __name__ == '__main__':
    main()
